import React, { useState, useEffect, useRef, useCallback } from 'react'
import { createClientSupabase } from '@/lib/supabase'
import { 
  SheetInfo, 
  SyncResult, 
  TableInfo, 
  ColumnInfo, 
  ColumnMapping, 
  CleanupStatus,
  RealTimeStats 
} from '@/types/data-sync'
import { getAutoMapping, getFallbackColumns } from '@/utils/columnMapping'
import { saveColumnMapping, loadColumnMapping } from '@/utils/localStorage'

export function useDataSync() {
  const [spreadsheetId] = useState('15pu3wMPDwOHlVM0LhRsOYW5WZDZ3SUPVU4h0G4hyLc0')
  const [selectedSheet, setSelectedSheet] = useState('')
  const [selectedTable, setSelectedTable] = useState('')
  const [sheetInfo, setSheetInfo] = useState<SheetInfo[]>([])
  const [availableTables, setAvailableTables] = useState<TableInfo[]>([])
  const [tableColumns, setTableColumns] = useState<ColumnInfo[]>([])
  const [columnMapping, setColumnMapping] = useState<ColumnMapping>({})
  const [loading, setLoading] = useState(false)
  const [syncResult, setSyncResult] = useState<SyncResult | null>(null)
  const [lastSyncTime, setLastSyncTime] = useState<string | null>(null)
  const [truncateTable, setTruncateTable] = useState(false)
  const [showMappingModal, setShowMappingModal] = useState(false)
  const [progress, setProgress] = useState(0)
  const [etaMs, setEtaMs] = useState<number | null>(null)
  const progressTimerRef = useRef<number | null>(null)
  const abortControllerRef = useRef<AbortController | null>(null)
  const [syncLogs, setSyncLogs] = useState<string[]>([])
  const [realTimeStats, setRealTimeStats] = useState<RealTimeStats>({ 
    processed: 0, 
    inserted: 0, 
    updated: 0, 
    errors: 0 
  })
  const [cleanupLoading, setCleanupLoading] = useState(false)
  const [cleanupResult, setCleanupResult] = useState<SyncResult | null>(null)
  const [cleanupStatus, setCleanupStatus] = useState<CleanupStatus | null>(null)

  // ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌÖåÏù¥Î∏î Í∞ÄÏ†∏Ïò§Í∏∞
  const getAvailableTables = useCallback(async () => {
    try {
      if (availableTables.length > 0) {
        return
      }

      const response = await fetch('/api/sync/all-tables')
      const result = await response.json()
      
      if (result.success) {
        setAvailableTables(result.data.tables)
        console.log('Available tables:', result.data.tables)
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('ÌÖåÏù¥Î∏î Î™©Î°ù ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.')
        return
      }
      
      console.error('Error getting available tables:', error)
    }
  }, [availableTables.length])

  // ÌÖåÏù¥Î∏î Ïä§ÌÇ§Îßà Í∞ÄÏ†∏Ïò§Í∏∞
  const getTableSchema = async (tableName: string) => {
    const attempt = async (timeoutMs: number) => {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs)
      try {
        const response = await fetch(`/api/sync/schema?table=${tableName}`, { signal: controller.signal })
        clearTimeout(timeoutId)
        return await response.json()
      } catch (err) {
        clearTimeout(timeoutId)
        throw err
      }
    }

    try {
      console.log('Fetching table schema for:', tableName)
      setTableColumns([])

      // 1Ï∞® ÏãúÎèÑ: 15Ï¥à
      let result = await attempt(15000)
      
      // Ïã§Ìå® ÌòπÏùÄ success=falseÏù¥Î©¥ 2Ï∞® Ïû¨ÏãúÎèÑ(25Ï¥à)
      if (!result?.success) {
        console.warn('Schema first attempt failed, retrying with longer timeout...')
        await new Promise(r => setTimeout(r, 500))
        result = await attempt(25000)
      }

      if (result?.success) {
        console.log('Setting table columns:', result.data.columns)
        console.log('Data source:', result.data.source)
        setTableColumns(result.data.columns)

        // ÏûêÎèô Îß§Ìïë Ï†ÅÏö© (Ï†ÄÏû•Îêú Îß§ÌïëÏù¥ ÏóÜÎäî Í≤ΩÏö∞)
        const savedMapping = loadColumnMapping(tableName)
        if (Object.keys(savedMapping).length === 0) {
          const sheet = sheetInfo.find(s => s.name === selectedSheet)
          if (sheet && sheet.columns.length > 0) {
            const autoMapping = getAutoMapping(result.data.columns, sheet.columns)
            if (Object.keys(autoMapping).length > 0) {
              console.log('Applying auto-mapping:', autoMapping)
              setColumnMapping(autoMapping)
            }
          }
        }
      } else {
        // Ìè¥Î∞±: ÌïòÎìúÏΩîÎî©Îêú Ïª¨Îüº Î™©Î°ù ÏÇ¨Ïö©
        const fallbackColumns = getFallbackColumns(tableName)
        console.warn('Using fallback columns (schema fetch returned unsuccessful):', fallbackColumns)
        setTableColumns(fallbackColumns)
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('Ïä§ÌÇ§Îßà ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.')
        return
      }
      
      // Ìè¥Î∞±: ÌïòÎìúÏΩîÎî©Îêú Ïª¨Îüº Î™©Î°ù ÏÇ¨Ïö©
      const fallbackColumns = getFallbackColumns(tableName)
      console.warn('Using fallback columns due to error:', error)
      setTableColumns(fallbackColumns)
    }
  }

  // Íµ¨Í∏Ä ÏãúÌä∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
  const getSheetInfo = async () => {
    if (!spreadsheetId.trim()) {
      alert('Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.')
      return
    }

    console.log('üöÄ Loading sheet information...')
    setLoading(true)
    setSheetInfo([])
    
    try {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }

      const controller = new AbortController()
      abortControllerRef.current = controller

      const timeoutId = setTimeout(() => {
        console.log('Request timeout - aborting fetch')
        controller.abort()
      }, 60000)

      console.log('Sending request to /api/sync/sheets')
      const response = await fetch('/api/sync/sheets', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ spreadsheetId }),
        signal: controller.signal
      })

      clearTimeout(timeoutId)
      abortControllerRef.current = null

      console.log('Response received:', response.status, response.statusText)
      
      if (!response.ok) {
        const errorText = await response.text()
        console.error('API Error Response:', errorText)
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`)
      }

      const result = await response.json()
      console.log('API Response:', result)
      
      if (result.success) {
        setSheetInfo(result.data.sheets)
        
        if (result.data.sheets.length > 0) {
          setSelectedSheet(result.data.sheets[0].name)
        } else {
          alert('ÏãúÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ïä§ÌîÑÎ†àÎìúÏãúÌä∏Ïóê "S"Î°ú ÏãúÏûëÌïòÎäî ÏãúÌä∏Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.')
        }
      } else {
        alert(`ÏãúÌä∏ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${result.message}`)
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§ (ÌÉÄÏûÑÏïÑÏõÉ ÎòêÎäî ÏÇ¨Ïö©Ïûê Ï∑®ÏÜå)')
        alert('ÏöîÏ≤≠ ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§ (60Ï¥à). ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî. Íµ¨Í∏Ä ÏãúÌä∏Í∞Ä ÎÑàÎ¨¥ ÌÅ¨Í±∞ÎÇò Î≥µÏû°Ìï† Ïàò ÏûàÏäµÎãàÎã§.')
        return
      }
      
      console.error('‚ùå Error:', error)
      
      let message = 'ÏãúÌä∏ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.'
      if (error instanceof Error) {
        if (error.message.includes('Quota exceeded')) {
          message = 'API Ìï†ÎãπÎüâÏùÑ Ï¥àÍ≥ºÌñàÏäµÎãàÎã§. 1-2Î∂Ñ ÌõÑÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
        } else if (error.message.includes('403')) {
          message = 'ÏãúÌä∏ Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ Í≥µÏú† ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.'
        } else if (error.message.includes('404')) {
          message = 'ÏãúÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ IDÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.'
        } else if (error.message.includes('Failed to fetch')) {
          message = 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞Ïù¥ Î∂àÏïàÏ†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.'
        } else {
          message = `Ïò§Î•ò: ${error.message}`
        }
      }
      
      alert(`‚ùå ${message}`)
      setSheetInfo([])
    } finally {
      setLoading(false)
    }
  }

  // ÏãúÌä∏ Ïª¨Îüº Ï†ïÎ≥¥ Î°úÎìú
  const loadSheetColumns = async (sheetName: string) => {
    try {
      console.log(`üìä Loading columns for ${sheetName}...`)
      
      const response = await fetch('/api/sync/sheet-columns', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          spreadsheetId, 
          sheetName 
        }),
      })

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      const result = await response.json()
      
      if (result.success) {
        setSheetInfo(prev => prev.map(sheet => 
          sheet.name === sheetName 
            ? { 
                ...sheet, 
                columns: result.data.columns,
                sampleData: result.data.sampleData
              }
            : sheet
        ))
        
        console.log(`‚úÖ Loaded ${result.data.columns.length} columns for ${sheetName}`)
      } else {
        console.error(`‚ùå Failed to load columns for ${sheetName}:`, result.message)
      }
    } catch (error) {
      console.error(`‚ùå Error loading columns for ${sheetName}:`, error)
    }
  }

  // ÏãúÌä∏ ÏÑ†ÌÉù
  const handleSheetSelect = async (sheetName: string) => {
    console.log(`üìã Selected sheet: ${sheetName}`)
    setSelectedSheet(sheetName)
    const sheet = sheetInfo.find(s => s.name === sheetName)
    
    if (sheet && sheet.columns.length === 0) {
      console.log(`üìä Loading column information for ${sheetName}...`)
      await loadSheetColumns(sheetName)
    }
  }

  // ÌÖåÏù¥Î∏î ÏÑ†ÌÉù
  const handleTableSelect = (tableName: string) => {
    console.log('Table selected:', tableName)
    setSelectedTable(tableName)
    setTableColumns([])
    setTruncateTable(false)
    
    if (tableName) {
      getTableSchema(tableName)
      fetchLastSyncTime(tableName)
      
      const savedMapping = loadColumnMapping(tableName)
      if (Object.keys(savedMapping).length > 0) {
        console.log('Loaded saved column mapping:', savedMapping)
        setColumnMapping(savedMapping)
      }
    }
  }

  // ÎßàÏßÄÎßâ ÎèôÍ∏∞Ìôî ÏãúÍ∞Ñ Ï°∞Ìöå
  const fetchLastSyncTime = async (tableName: string) => {
    if (!spreadsheetId) return
    
    try {
      const response = await fetch(`/api/sync/history?table=${tableName}&spreadsheetId=${spreadsheetId}`)
      const result = await response.json()
      
      if (result.success && result.data.lastSyncTime) {
        setLastSyncTime(result.data.lastSyncTime)
      } else {
        setLastSyncTime(null)
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('ÎßàÏßÄÎßâ ÎèôÍ∏∞Ìôî ÏãúÍ∞Ñ ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.')
        return
      }
      
      console.error('Error fetching last sync time:', error)
      setLastSyncTime(null)
    }
  }

  // ÏöîÏ≤≠ Ï∑®ÏÜå
  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
      console.log('ÏÇ¨Ïö©ÏûêÍ∞Ä ÏöîÏ≤≠ÏùÑ Ï∑®ÏÜåÌñàÏäµÎãàÎã§.')
    }
  }

  // Íµ¨Í∏Ä ÏãúÌä∏ URL ÏÉùÏÑ±
  const getGoogleSheetsUrl = () => {
    return `https://docs.google.com/spreadsheets/d/${spreadsheetId}`
  }

  // Íµ¨Í∏Ä ÏãúÌä∏ Ïó¥Í∏∞
  const openGoogleSheets = () => {
    window.open(getGoogleSheetsUrl(), '_blank')
  }

  // ÏòàÏïΩ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ÏÉÅÌÉú ÌôïÏù∏
  const checkCleanupStatus = async () => {
    try {
      const response = await fetch('/api/sync/reservation-cleanup')
      const result = await response.json()
      
      if (result.success) {
        setCleanupStatus(result.data)
      } else {
        console.error('Failed to check cleanup status:', result.message)
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('Ï†ïÎ¶¨ ÏÉÅÌÉú ÌôïÏù∏ ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.')
        return
      }
      
      console.error('Error checking cleanup status:', error)
    }
  }

  // ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞Ìôî Ìï®Ïàò Ï∂îÍ∞Ä
  const handleOptimizedSync = async () => {
    const supabase = createClientSupabase()
    const { data: { session } } = await supabase.auth.getSession()
    const accessToken = session?.access_token
    
    if (!accessToken) {
      alert('Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Í∞Ä ÌôïÏù∏ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ® ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')
      return
    }
    
    if (!spreadsheetId.trim() || !selectedSheet || !selectedTable) {
      alert('Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ ID, ÏãúÌä∏, ÌÖåÏù¥Î∏îÏùÑ Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
      return
    }

    if (Object.keys(columnMapping).length === 0) {
      alert('Ïª¨Îüº Îß§ÌïëÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.')
      return
    }

    setLoading(true)
    setSyncResult(null)
    setProgress(1)
    setSyncLogs([])
    setRealTimeStats({ processed: 0, inserted: 0, updated: 0, errors: 0 })
    
    const startTs = Date.now()
    setEtaMs(null) // ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞ÌôîÎäî Ï†ïÌôïÌïú ÏòàÏ∏°Ïù¥ Ïñ¥Î†§ÏõÄ

    try {
      const response = await fetch('/api/sync/optimized', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`
        },
        body: JSON.stringify({
          spreadsheetId,
          sheetName: selectedSheet,
          targetTable: selectedTable,
          columnMapping
        })
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      
      if (result.success) {
        setSyncResult({
          success: true,
          message: result.message,
          data: result.data,
          count: result.count
        })
        setLastSyncTime(new Date().toISOString())
        
        const durationMs = Date.now() - startTs
        const rowsProcessed = result.count || 0
        const msPerRow = rowsProcessed > 0 ? Math.round(durationMs / rowsProcessed) : 0
        
        setSyncLogs(prev => [...prev, `‚úÖ ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞Ìôî ÏôÑÎ£å: ${rowsProcessed}Í∞ú Ìñâ Ï≤òÎ¶¨ (${msPerRow}ms/Ìñâ)`])
        
        // ÏÑ±Îä• Í∞úÏÑ† Î°úÍ∑∏
        if (msPerRow < 10) {
          setSyncLogs(prev => [...prev, `üöÄ Ïö∞ÏàòÌïú ÏÑ±Îä•: ${msPerRow}ms/Ìñâ (Î™©Ìëú: <10ms/Ìñâ)`])
        } else if (msPerRow < 50) {
          setSyncLogs(prev => [...prev, `‚ö° ÏñëÌò∏Ìïú ÏÑ±Îä•: ${msPerRow}ms/Ìñâ (Î™©Ìëú: <50ms/Ìñâ)`])
        } else {
          setSyncLogs(prev => [...prev, `‚ö†Ô∏è ÏÑ±Îä• Í∞úÏÑ† ÌïÑÏöî: ${msPerRow}ms/Ìñâ`])
        }
      } else {
        setSyncResult({ success: false, message: result.message })
        setSyncLogs(prev => [...prev, `‚ùå ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${result.message}`])
      }
    } catch (error) {
      console.error('ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞Ìôî Ïò§Î•ò:', error)
      setSyncResult({
        success: false,
        message: 'ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      })
      setSyncLogs(prev => [...prev, `‚ùå Ïò§Î•ò: ${error}`])
    } finally {
      setProgress(100)
      setEtaMs(0)
      setLoading(false)
    }
  }
    const supabase = createClientSupabase()
    const { data: { session } } = await supabase.auth.getSession()
    const accessToken = session?.access_token
    if (!accessToken) {
      alert('Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Í∞Ä ÌôïÏù∏ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ® ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')
      setLoading(false)
      return
    }
    if (!spreadsheetId.trim() || !selectedSheet || !selectedTable) {
      alert('Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ ID, ÏãúÌä∏, ÌÖåÏù¥Î∏îÏùÑ Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
      return
    }

    if (Object.keys(columnMapping).length === 0) {
      alert('Ïª¨Îüº Îß§ÌïëÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.')
      return
    }

    setLoading(true)
    setSyncResult(null)
    setProgress(1)
    setSyncLogs([])
    setRealTimeStats({ processed: 0, inserted: 0, updated: 0, errors: 0 })
    
    const defaultMsPerRow = Number(localStorage.getItem('flex-sync-ms-per-row')) || 10
    const sheet = sheetInfo.find(s => s.name === selectedSheet)
    const estimatedRows = Math.max(sheet?.rowCount || 200, 1)
    const estimatedDurationMs = Math.max(estimatedRows * defaultMsPerRow, 1500)
    const startTs = Date.now()
    setEtaMs(estimatedDurationMs)
    
    if (progressTimerRef.current) {
      clearInterval(progressTimerRef.current)
      progressTimerRef.current = null
    }
    progressTimerRef.current = window.setInterval(() => {
      const elapsed = Date.now() - startTs
      const pct = Math.min(95, Math.floor((elapsed / estimatedDurationMs) * 95))
      setProgress(pct)
      setEtaMs(Math.max(estimatedDurationMs - elapsed, 0))
    }, 200)

    try {
      const response = await fetch('/api/sync/flexible/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {})
        },
        body: JSON.stringify({
          spreadsheetId,
          sheetName: selectedSheet,
          targetTable: selectedTable,
          columnMapping,
          enableIncrementalSync: false,
          truncateTable,
        }),
      })

      if (!response.body) throw new Error('No response body')
      const reader = response.body.getReader()
      const decoder = new TextDecoder()
      let buffered = ''
      let finalResult: SyncResult | null = null

      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        buffered += decoder.decode(value, { stream: true })
        const lines = buffered.split('\n')
        buffered = lines.pop() || ''
        for (const line of lines) {
          if (!line.trim()) continue
          try {
            const evt = JSON.parse(line)
            
            if (evt.type === 'info') {
              setSyncLogs(prev => [...prev, `[INFO] ${evt.message}`])
            } else if (evt.type === 'warn') {
              setSyncLogs(prev => [...prev, `[WARN] ${evt.message}`])
            } else if (evt.type === 'error') {
              setSyncLogs(prev => [...prev, `[ERROR] ${evt.message}`])
            }
            
            if (evt.type === 'start' && evt.total) {
              const msPerRow = Number(localStorage.getItem('flex-sync-ms-per-row')) || 10
              const newEstimated = Math.max(evt.total * msPerRow, 1500)
              setEtaMs(newEstimated)
              setSyncLogs(prev => [...prev, `[START] ÎèôÍ∏∞Ìôî ÏãúÏûë - Ï¥ù ${evt.total}Í∞ú Ìñâ Ï≤òÎ¶¨ ÏòàÏ†ï`])
            }
            if (evt.type === 'progress' && evt.total) {
              const pctRaw = Math.floor((evt.processed / evt.total) * 100)
              setProgress(prev => Math.min(99, Math.max(prev, pctRaw)))
              const elapsed = Date.now() - startTs
              const perRow = (evt.processed > 0) ? Math.round(elapsed / evt.processed) : (Number(localStorage.getItem('flex-sync-ms-per-row')) || 10)
              const remain = Math.max((evt.total - evt.processed) * perRow, 0)
              setEtaMs(remain)
              
              setRealTimeStats({
                processed: evt.processed || 0,
                inserted: evt.inserted || 0,
                updated: evt.updated || 0,
                errors: evt.errors || 0
              })
              
              if (evt.processed > 0 && evt.processed % Math.max(1, Math.floor(evt.total / 10)) === 0) {
                setSyncLogs(prev => [...prev, `[PROGRESS] ${evt.processed}/${evt.total} Ï≤òÎ¶¨ ÏôÑÎ£å (${pctRaw}%) - ÏÇΩÏûÖ: ${evt.inserted || 0}, ÏóÖÎç∞Ïù¥Ìä∏: ${evt.updated || 0}, Ïò§Î•ò: ${evt.errors || 0}`])
              }
            }
            if (evt.type === 'result') {
              finalResult = {
                success: !!evt.success,
                message: String(evt.message || ''),
                data: evt.details,
                syncTime: new Date().toISOString()
              }
              setSyncLogs(prev => [...prev, `[RESULT] ÎèôÍ∏∞Ìôî ÏôÑÎ£å - ${finalResult?.message || 'Ïïå Ïàò ÏóÜÎäî Í≤∞Í≥º'}`])
            }
          } catch {
            // Î¨¥Ïãú (Î∂ÄÎ∂Ñ ÎùºÏù∏)
          }
        }
      }

      if (finalResult) {
        setSyncResult(finalResult)
        if (finalResult.success) {
          setLastSyncTime(new Date().toISOString())
          const durationMs = Date.now() - startTs
          const inserted = finalResult.data?.inserted ?? 0
          const updated = finalResult.data?.updated ?? 0
          const processedSum = inserted + updated
          const rowsProcessed = Math.max(processedSum > 0 ? processedSum : estimatedRows, 1)
          const msPerRow = Math.min(Math.max(Math.round(durationMs / rowsProcessed), 3), 200)
          localStorage.setItem('flex-sync-ms-per-row', String(msPerRow))
        }
      } else {
        setSyncResult({ success: false, message: 'ÎèôÍ∏∞Ìôî Í≤∞Í≥ºÎ•º ÏàòÏã†ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.' })
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('ÎèôÍ∏∞Ìôî ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§ (ÌÉÄÏûÑÏïÑÏõÉ ÎòêÎäî ÏÇ¨Ïö©Ïûê Ï∑®ÏÜå)')
        setSyncResult({
          success: false,
          message: 'ÎèôÍ∏∞ÌôîÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§. ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
        })
        return
      }
      
      console.error('Error syncing data:', error)
      setSyncResult({
        success: false,
        message: 'Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      })
    } finally {
      if (progressTimerRef.current) {
        clearInterval(progressTimerRef.current)
        progressTimerRef.current = null
      }
      setProgress(100)
      setEtaMs(0)
      setLoading(false)
    }
  }

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÌÖåÏù¥Î∏îÎßå Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    getAvailableTables()
  }, [getAvailableTables])

  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÏßÑÌñâ Ï§ëÏù∏ ÏöîÏ≤≠ Ï∑®ÏÜå
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
        abortControllerRef.current = null
      }
    }
  }, [])

  // ÏòàÏïΩ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    checkCleanupStatus()
  }, [])

  return {
    // ÏÉÅÌÉú
    spreadsheetId,
    selectedSheet,
    selectedTable,
    sheetInfo,
    availableTables,
    tableColumns,
    columnMapping,
    loading,
    syncResult,
    lastSyncTime,
    truncateTable,
    showMappingModal,
    progress,
    etaMs,
    syncLogs,
    realTimeStats,
    cleanupLoading,
    cleanupResult,
    cleanupStatus,
    
    // Ïï°ÏÖò
    setColumnMapping,
    setTruncateTable,
    setShowMappingModal,
    setSyncResult,
    setCleanupResult,
    getSheetInfo,
    cancelRequest,
    openGoogleSheets,
    handleSheetSelect,
    handleTableSelect,
    handleFlexibleSync,
    handleOptimizedSync, // ÏÉàÎ°úÏö¥ ÏµúÏ†ÅÌôîÎêú ÎèôÍ∏∞Ìôî Ìï®Ïàò Ï∂îÍ∞Ä
    checkCleanupStatus,
    saveColumnMapping: (tableName: string, mapping: ColumnMapping) => {
      saveColumnMapping(tableName, mapping)
      setColumnMapping(mapping)
    }
  }
}
